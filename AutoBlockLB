-- Auto Block + Auto Punish + Auto Counter - JUN ULT + SHINJI + MARTIAL ARTIST ULT
-- Versión actualizada: Enero 2026
-- Nueva característica: Pestaña Cam Lock con toggle en menú

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

Library.ForceCheckbox = false
Library.ShowToggleFrameInKeybinds = true

local Window = Library:CreateWindow({
    Title = "Auto Block + Punish + Counter",
    Footer = "JUN ULT + SHINJI + MARTIAL ULT - Updated 2026.01.04",
    Icon = 95816097006870,
    NotifySide = "Right",
    ShowCustomCursor = true,
})

local Tabs = {
    Main = Window:AddTab("Main", "user"),
    Settings = Window:AddTab("Settings", "settings"),
    CamLock = Window:AddTab("Cam Lock", "crosshair"),  -- NUEVA PESTAÑA
    ["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

-- Features
local MainGroup = Tabs.Main:AddLeftGroupbox("Features", "boxes")

MainGroup:AddToggle("EnableAutoBlock", {
    Text = "Enable Auto Block",
    Default = true,
})

MainGroup:AddToggle("EnableAutoPunish", {
    Text = "Enable Auto Punish",
    Default = true,
})

MainGroup:AddToggle("EnableAutoCounter", {
    Text = "Enable Auto Counter",
    Default = true,
})

-- Configurations
local SettingsGroup = Tabs.Settings:AddLeftGroupbox("Configurations", "sliders")

SettingsGroup:AddSlider("MaxDistance", {
    Text = "Max Detection Distance",
    Default = 25,
    Min = 10,
    Max = 50,
    Rounding = 0,
})

SettingsGroup:AddSlider("BehindDistance", {
    Text = "Behind Distance",
    Default = 18,
    Min = 5,
    Max = 30,
    Rounding = 0,
})

SettingsGroup:AddSlider("CounterDistance", {
    Text = "Counter Distance",
    Default = 12,
    Min = 5,
    Max = 20,
    Rounding = 0,
})

SettingsGroup:AddSlider("AngleThreshold", {
    Text = "Angle Threshold",
    Default = 120,
    Min = 90,
    Max = 180,
    Rounding = 0,
})

SettingsGroup:AddSlider("StrictBehindAngle", {
    Text = "Strict Behind Angle",
    Default = 140,
    Min = 120,
    Max = 180,
    Rounding = 0,
})

SettingsGroup:AddSlider("AttackCooldown", {
    Text = "Attack Cooldown",
    Default = 0.32,
    Min = 0.1,
    Max = 1.0,
    Rounding = 2,
})

SettingsGroup:AddSlider("AudioMaxDistance", {
    Text = "Audio Detection Distance",
    Default = 35,
    Min = 15,
    Max = 60,
    Rounding = 0,
    Tooltip = "Maximum distance to detect Shinji audio",
})

-- Services & Variables
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Anim Types ORDENADAS por personaje
local animTypes = {
    -- JUN M1s
    ["95971182752543"] = "normal",
    ["74711059252371"] = "normal",
    ["129048750359824"] = "normal",
    ["129536653447724"] = "normal",
    -- JUN Skills
    ["18542392001"] = "direct",
    ["18681089831"] = "block_02",
    ["18955032062"] = "block_04",
    ["103530817046655"] = "block_120",
    -- JUN ULTIMATE Skills (bloqueo corto + radio largo)
    ["82028453200408"] = "block_ulti_jun_short",   -- Jun Ulti Skill 2
    ["100511842000786"] = "block_ulti_jun_short",  -- Jun Ulti Skill 3

    -- SHINJI M1s
    ["76966635202046"] = "normal",
    ["102448117900479"] = "normal",
    ["111296208946579"] = "shinji_m1_3",
    ["100278816358393"] = "shinji_m1_4",
    -- SHINJI Skills
    ["125348562455925"] = "block_120",
    ["126102858255615"] = "block_10",
    ["102273007149848"] = "direct",

    -- MARTIAL ARTIST
    ["18193105588"] = "normal",
    ["15753464160"] = "normal",
    ["18193099953"] = "normal",
    ["15779089411"] = "normal",
    ["15883604707"] = "block_normal",
    ["15885657454"] = "direct",
    ["16058228731"] = "direct",
    ["15753705218"] = "block_10",
    ["16916082286"] = "block_02",
    ["17230392848"] = "block_ulti",    -- Martial Ultimate
}

local punishDelays = {
    normal = 0.15,
    block_normal = 0.18,
    block_02 = 0.20,
    block_04 = 0.40,
    block_10 = 1.00,
    block_120 = 1.20,
    block_ulti = 2.50,
    block_ulti_jun_short = 0.50,       -- Bloqueo de solo 0.50s para ambas Jun Ulti 2 y 3
    martial_h3_special = 2.30,
    shinji_m1_3 = 0.40,
    shinji_m1_4 = 0.50,
}

local counterFrontAnims = {
    "18955032062",
    "102273007149848",
    "15753705218"
}

-- Estados
local fDownSent = false
local lastAttackTime = 0
local isPunishing = false
local isAudioBlocking = false

-- Funciones auxiliares
local function getNearestPlayer(maxDist)
    local nearest, shortest = nil, maxDist
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return nil end
    
    local myPos = myChar.HumanoidRootPart.Position
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local dist = (plr.Character.HumanoidRootPart.Position - myPos).Magnitude
            if dist < shortest then
                shortest = dist
                nearest = plr
            end
        end
    end
    return nearest, shortest
end

local function isFacingMe(target)
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return false end
    local targetRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return false end
    
    local dirToMe = (myChar.HumanoidRootPart.Position - targetRoot.Position).Unit
    local targetLook = targetRoot.CFrame.LookVector
    local dot = math.clamp(targetLook:Dot(dirToMe), -1, 1)
    return math.deg(math.acos(dot)) <= Options.AngleThreshold.Value
end

local function isStrictlyBehindMe(target)
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return false end
    local targetRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return false end
    
    local myRoot = myChar.HumanoidRootPart
    local dirToTarget = (targetRoot.Position - myRoot.Position).Unit
    local myLook = myRoot.CFrame.LookVector
    local dot = math.clamp(myLook:Dot(dirToTarget), -1, 1)
    local angle = math.deg(math.acos(dot))
    local distance = (targetRoot.Position - myRoot.Position).Magnitude
    
    return angle > Options.StrictBehindAngle.Value and distance <= Options.CounterDistance.Value
end

local function isBehindMe(target)
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return false end
    local targetRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return false end
    
    local myRoot = myChar.HumanoidRootPart
    local dirToTarget = (targetRoot.Position - myRoot.Position).Unit
    local myLook = myRoot.CFrame.LookVector
    local dot = math.clamp(myLook:Dot(dirToTarget), -1, 1)
    local angle = math.deg(math.acos(dot))
    local distance = (targetRoot.Position - myRoot.Position).Magnitude
    
    return angle > Options.AngleThreshold.Value and distance <= Options.BehindDistance.Value
end

local function getAnimTypeAndId(target)
    local humanoid = target.Character and target.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return nil, nil end
    
    for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
        if track.IsPlaying and track.Animation then
            local animId = string.match(track.Animation.AnimationId, "(%d+)")
            if animId then
                if animId == "15753705218" then
                    return "martial_h3_special", animId
                end
                if animTypes[animId] then
                    return animTypes[animId], animId
                end
            end
        end
    end
    return nil, nil
end

local function sendRequest(request)
    local network = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Network")
    if not network then return false end
    network:FireServer({Request = request})
    return true
end

local function sendCounterRequest()
    local network = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Network")
    if not network then return false end
    network:FireServer({Number = "4", Request = "Skill"})
    return true
end

local function executePunish()
    if sendRequest("M1Down") then
        task.wait(0.08)
        sendRequest("M1Up")
    end
end

-- Heartbeat principal
RunService.Heartbeat:Connect(function()
    if not (Toggles.EnableAutoBlock.Value or Toggles.EnableAutoPunish.Value or Toggles.EnableAutoCounter.Value) then
        return
    end

    local myChar = LocalPlayer.Character
    if not myChar or not myChar.Parent or not myChar:FindFirstChild("Network") or not myChar:FindFirstChild("HumanoidRootPart") then
        if fDownSent then 
            sendRequest("FUp") 
            fDownSent = false 
        end
        return
    end

    local currentTime = tick()

    -- Detección especial para Jun Ulti Skill 2 y 3: radio de 50 studs
    local nearestJunUlti, distJunUlti = getNearestPlayer(50)  -- Radio extendido solo para estas habilidades
    if nearestJunUlti and nearestJunUlti.Character and nearestJunUlti.Character:FindFirstChild("HumanoidRootPart") then
        local animType, animId = getAnimTypeAndId(nearestJunUlti)
        if animType == "block_ulti_jun_short" then
            if Toggles.EnableAutoBlock.Value and not fDownSent and not isPunishing then
                sendRequest("FDown")
                fDownSent = true

                if Toggles.EnableAutoPunish.Value and currentTime - lastAttackTime >= Options.AttackCooldown.Value then
                    isPunishing = true
                    task.spawn(function()
                        task.wait(punishDelays.block_ulti_jun_short)  -- 0.50s
                        if fDownSent then 
                            sendRequest("FUp")
                            fDownSent = false 
                        end
                        executePunish()
                        lastAttackTime = tick()
                        isPunishing = false
                    end)
                else
                    -- Si solo bloqueo, lo quita después de 0.50s
                    task.spawn(function()
                        task.wait(punishDelays.block_ulti_jun_short)
                        if fDownSent then
                            sendRequest("FUp")
                            fDownSent = false
                        end
                    end)
                end
                return
            end
        end
    end

    -- Detección normal (radio configurado por slider)
    local nearest = getNearestPlayer(Options.MaxDistance.Value)
    if nearest and nearest.Character and nearest.Character:FindFirstChild("HumanoidRootPart") then
        local animType, animId = getAnimTypeAndId(nearest)

        if animType then
            -- Prioridad 1: Counter detrás
            if Toggles.EnableAutoCounter.Value and isStrictlyBehindMe(nearest) and animTypes[animId] then
                if fDownSent then sendRequest("FUp"); fDownSent = false end
                sendCounterRequest()
                return
            end

            -- Prioridad 2: Counter frontal
            if Toggles.EnableAutoCounter.Value and table.find(counterFrontAnims, animId) and isFacingMe(nearest) then
                if fDownSent then sendRequest("FUp"); fDownSent = false end
                sendCounterRequest()
                return
            end

            local shouldBlock = false
            local customBlockDuration = nil

            if animType == "martial_h3_special" then
                shouldBlock = Toggles.EnableAutoBlock.Value
                customBlockDuration = punishDelays.martial_h3_special
            else
                if animType == "direct" then
                    if Toggles.EnableAutoPunish.Value and currentTime - lastAttackTime >= Options.AttackCooldown.Value and not isPunishing then
                        if fDownSent then sendRequest("FUp"); fDownSent = false end
                        isPunishing = true
                        task.spawn(function()
                            executePunish()
                            lastAttackTime = tick()
                            isPunishing = false
                        end)
                    end
                    return
                elseif string.find(animType, "block_") and animType ~= "block_ulti_jun_short" or string.find(animType, "shinji_m1_") then
                    shouldBlock = Toggles.EnableAutoBlock.Value
                elseif animType == "normal" then
                    shouldBlock = Toggles.EnableAutoBlock.Value and (isFacingMe(nearest) or isBehindMe(nearest))
                end
            end

            if shouldBlock and not fDownSent and not isPunishing then
                sendRequest("FDown")
                fDownSent = true

                if Toggles.EnableAutoPunish.Value and currentTime - lastAttackTime >= Options.AttackCooldown.Value then
                    isPunishing = true
                    task.spawn(function()
                        local waitTime = customBlockDuration or (punishDelays[animType] or punishDelays.normal)
                        task.wait(waitTime)
                        if fDownSent then 
                            sendRequest("FUp")
                            fDownSent = false 
                        end
                        executePunish()
                        lastAttackTime = tick()
                        isPunishing = false
                    end)
                end
                return
            end
        end
    end

    if fDownSent and not isPunishing and not isAudioBlocking then
        sendRequest("FUp")
        fDownSent = false
    end
end)

-- Audio detection (Shinji) - Sin cambios
local targetAudioId = "rbxassetid://107838666135851"

local function tryGetPlayerFromSound(sound)
    local current = sound.Parent
    while current and current ~= game do
        if current:IsA("Model") then
            local player = Players:GetPlayerFromCharacter(current)
            if player then
                return player, current
            end
        end
        current = current.Parent
    end
    return nil, nil
end

local function onSoundPlayed(sound)
    if not (Toggles.EnableAutoBlock.Value and Toggles.EnableAutoPunish.Value) then return end

    local player, character = tryGetPlayerFromSound(sound)
    if not player or player == LocalPlayer then return end

    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local enemyRoot = character and character:FindFirstChild("HumanoidRootPart")
    if not myRoot or not enemyRoot then return end

    local distance = (myRoot.Position - enemyRoot.Position).Magnitude
    if distance > Options.AudioMaxDistance.Value then return end

    task.spawn(function()
        isAudioBlocking = true
        if not fDownSent then
            sendRequest("FDown")
            fDownSent = true
        end
        task.wait(2.5)
        if fDownSent then
            sendRequest("FUp")
            fDownSent = false
        end
        isAudioBlocking = false
        executePunish()
    end)
end

local function setupAudioDetection()
    for _, obj in ipairs(game:GetDescendants()) do
        if obj:IsA("Sound") and obj.SoundId == targetAudioId then
            for _, c in ipairs(getconnections(obj.Played)) do
                pcall(function() c:Disable() end)
            end
            obj.Played:Connect(function() onSoundPlayed(obj) end)
        end
    end

    game.DescendantAdded:Connect(function(desc)
        if desc:IsA("Sound") and desc.SoundId == targetAudioId then
            for _, c in ipairs(getconnections(desc.Played)) do
                pcall(function() c:Disable() end)
            end
            desc.Played:Connect(function() onSoundPlayed(desc) end)
        end
    end)
end

setupAudioDetection()

-- === NUEVA SECCIÓN: Cam Lock ===
local CamLockGroup = Tabs.CamLock:AddLeftGroupbox("Cam Lock Control", "crosshair")

CamLockGroup:AddToggle("EnableCamLock", {
    Text = "Enable Cam Lock",
    Default = false,
    Tooltip = "Activa/desactiva el cam lock (también se puede usar Q o DPadUp)",
})

-- === CÓDIGO DEL CAM LOCK (se ejecuta solo si el toggle está activado) ===
local camlockHeartbeatConnection = nil
local camlockGui = nil

local function startCamLock()
    if camlockHeartbeatConnection then return end

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")

    local LocalPlayer = Players.LocalPlayer
    local Camera = workspace.CurrentCamera

    -- Configuración
    getgenv().CamlockSettings = {
        Key = Enum.KeyCode.Q,
        GamepadKey = Enum.KeyCode.DPadUp,
        MaxDistance = 300,
        
        BasePrediction = 0.0100,          
        MaxPrediction = 0.27,            
        AccelerationThreshold = 30,      
        SmoothFactor = 0.50,             
        AimSmoothness = 0.70,           
        
        ActiveColor = Color3.fromRGB(60, 255, 120),
        InactiveColor = Color3.fromRGB(255, 60, 80),
        TextColor = Color3.fromRGB(220, 220, 235),
    }

    local settings = getgenv().CamlockSettings

    -- Variables
    local enabled = false
    local currentTarget = nil
    local currentPrediction = settings.BasePrediction
    local lastVelocity = Vector3.new()
    local buttonHiddenPermanently = false

    -- GUI
    camlockGui = Instance.new("ScreenGui")
    camlockGui.Name = "MinimalCamlock"
    camlockGui.ResetOnSpawn = false
    camlockGui.Parent = game:GetService("CoreGui")

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 86, 0, 42)
    button.Position = UDim2.new(0.5, -43, 0.88, -21)
    button.AnchorPoint = Vector2.new(0.5, 0.5)
    button.BackgroundTransparency = 1
    button.Text = "OFF"
    button.TextColor3 = settings.TextColor
    button.TextSize = 16
    button.Font = Enum.Font.GothamSemibold
    button.TextXAlignment = Enum.TextXAlignment.Center
    button.AutoButtonColor = false
    button.Active = true
    button.Draggable = true
    button.Parent = camlockGui

    local uiStroke = Instance.new("UIStroke")
    uiStroke.Color = settings.InactiveColor
    uiStroke.Thickness = 1.4
    uiStroke.Transparency = 0
    uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    uiStroke.Parent = button

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = button

    -- Actualizar GUI
    local function updateGUI()
        if buttonHiddenPermanently then
            button.Visible = false
            return
        end

        if enabled then
            button.Text = "ON"
            uiStroke.Color = settings.ActiveColor
        else
            button.Text = "OFF"
            uiStroke.Color = settings.InactiveColor
        end
        button.Visible = true
    end

    -- Detectar objetivo más cercano (incluye Weakest Dummy)
    local function findClosestTarget()
        local closestModel = nil
        local shortestDistance = settings.MaxDistance
        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

        -- 1. Jugadores normales
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local model = player.Character
                local humanoid = model:FindFirstChildOfClass("Humanoid")
                local root = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Torso")
                if humanoid and humanoid.Health > 0 and root then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(root.Position)
                    if onScreen then
                        local distance = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            closestModel = model
                        end
                    end
                end
            end
        end

        -- 2. Dummies en workspace.Characters
        local charactersFolder = workspace:FindFirstChild("Characters")
        if charactersFolder then
            for _, model in ipairs(charactersFolder:GetChildren()) do
                if model:IsA("Model") and model ~= LocalPlayer.Character then
                    local humanoid = model:FindFirstChildOfClass("Humanoid")
                    local root = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Torso")
                    if humanoid and humanoid.Health > 0 and root then
                        local screenPos, onScreen = Camera:WorldToViewportPoint(root.Position)
                        if onScreen then
                            local distance = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                            if distance < shortestDistance then
                                shortestDistance = distance
                                closestModel = model
                            end
                        end
                    end
                end
            end
        end

        -- 3. Weakest Dummy específico en workspace.Live
        local liveFolder = workspace:FindFirstChild("Live")
        if liveFolder then
            local weakestDummy = liveFolder:FindFirstChild("Weakest Dummy")
            if weakestDummy then
                local humanoid = weakestDummy:FindFirstChildOfClass("Humanoid")
                local torso = weakestDummy:FindFirstChild("Torso")  -- Usa Torso como root
                if humanoid and humanoid.Health > 0 and torso then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(torso.Position)
                    if onScreen then
                        local distance = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            closestModel = weakestDummy
                        end
                    end
                end
            end
        end

        return closestModel
    end

    -- Lógica del camlock
    camlockHeartbeatConnection = RunService.Heartbeat:Connect(function(deltaTime)
        if not enabled then return end

        if currentTarget then
            -- Prioriza HumanoidRootPart, luego Torso (compatible con R6 y Weakest Dummy)
            local root = currentTarget:FindFirstChild("HumanoidRootPart") or currentTarget:FindFirstChild("Torso")
            if root then
                local currentVel = root.Velocity
                local acceleration = (currentVel - lastVelocity) / deltaTime
                lastVelocity = currentVel

                local accelMag = acceleration.Magnitude

                if accelMag > settings.AccelerationThreshold then
                    currentPrediction = currentPrediction + (settings.MaxPrediction - currentPrediction) * settings.SmoothFactor * 2
                else
                    currentPrediction = currentPrediction + (settings.BasePrediction - currentPrediction) * settings.SmoothFactor
                end

                currentPrediction = math.clamp(currentPrediction, settings.BasePrediction, settings.MaxPrediction)

                local predPos = root.Position + (currentVel * currentPrediction)
                local targetCFrame = CFrame.lookAt(Camera.CFrame.Position, predPos)
                Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, settings.AimSmoothness)
            else
                currentTarget = findClosestTarget()
                lastVelocity = Vector3.new()
            end
        else
            currentTarget = findClosestTarget()
            lastVelocity = Vector3.new()
        end
    end)

    -- Toggle
    local function toggleCamlock(activatedWithGamepad)
        enabled = not enabled
        currentTarget = enabled and findClosestTarget() or nil
        lastVelocity = Vector3.new()
        currentPrediction = settings.BasePrediction

        if activatedWithGamepad and enabled then
            buttonHiddenPermanently = true
        end

        updateGUI()
    end

    -- Input
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        local isGamepad = input.KeyCode == settings.GamepadKey
        local isKeyboard = input.KeyCode == settings.Key

        if isGamepad or isKeyboard then
            toggleCamlock(isGamepad)
        end
    end)

    button.MouseButton1Click:Connect(function()
        toggleCamlock(false)
    end)

    -- Inicializar
    updateGUI()

    -- Limpieza
    camlockGui.Destroying:Connect(function()
        if camlockHeartbeatConnection then
            camlockHeartbeatConnection:Disconnect()
        end
    end)
end

local function stopCamLock()
    if camlockHeartbeatConnection then
        camlockHeartbeatConnection:Disconnect()
        camlockHeartbeatConnection = nil
    end
    if camlockGui then
        camlockGui:Destroy()
        camlockGui = nil
    end
end

-- Conexión con el toggle del menú
Toggles.EnableCamLock:OnChanged(function()
    if Toggles.EnableCamLock.Value then
        startCamLock()
    else
        stopCamLock()
    end
end)

-- UI Settings
local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu", "wrench")

MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "Custom Cursor",
    Default = true,
    Callback = function(v) Library.ShowCustomCursor = v end,
})

MenuGroup:AddDropdown("NotificationSide", {
    Values = { "Left", "Right" },
    Default = "Right",
    Text = "Notification Side",
    Callback = function(v) Library:SetNotifySide(v) end,
})

MenuGroup:AddKeyPicker("MenuKeybind", {
    Default = "RightShift",
    Text = "Menu Keybind",
    NoUI = true,
})

MenuGroup:AddButton("Unload Script", function()
    stopCamLock()  -- Limpia el cam lock al unload
    Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({"MenuKeybind"})
ThemeManager:SetFolder("AutoBlockHub")
SaveManager:SetFolder("AutoBlockHub/game")
SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])
SaveManager:LoadAutoloadConfig()
